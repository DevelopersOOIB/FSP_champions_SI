# Cubic equation
**Описание**: Я придумал хеш-функцию, основанную на кубических уравнениях. Проверь её на односторонность.

# Writeup 
Перед нами результат уравнения:
$$c=89x^3  + 4x^2  + 3x + 7 (\mod p)$$
И нам необходимо решить это кубическое уравнение. Конечно, его можно решить методом Кардано, только по модулю простого числа. Но есть способ лучше. Можно использовать эллиптические кривые. Возьмём следующую кривую:
$$E: y^2=x^3  +  \frac{4}{89}x^2  +  \frac{3}{89}x + \frac{7-с}{89}  (mod p)$$
После найдём её порядок $E.order()$. И возведём умножим любую точку генерации кривой на $\frac{E.order()}{2}$ тогда порядок этой точки станет равный 2. То есть эта точка порождает две точки – это точка бесконечности и ещё одна точка. А точка, которая в сумме сама с собой может давать точку бесконечности это точка с нулевой координатой y. А значит её координата x будет корнем кубического уравнения. 
Для решения можно составить следующий код на языке **SageMath**:
```python
p = 0x19a65c04a61ae5d64265afa9cfb2dbe931054969b4aeb872cae33a1b043865369
y = 0x46338455b2972769aa5e652aa692118db4d49d00f21f15ff4f014f18d4c05eb6

def main():
    a1, a2, a3, a4, a6 = 0, 4, 0, 3, 7
    inv89 = pow(89, -1, p)
    a2 = (a2 * inv89) % p
    a4 = (a4 * inv89) % p
    a6 = ((a6 - y) * inv89) % p
    E = EllipticCurve(GF(p), [a1, a2, a3, a4, a6])
    Len_E = E.order()
    G = E.gens()[0]
    flag = (G * (Len_E // 2))[0]
    print(int(flag).to_bytes(32, byteorder = 'big'))
    
if __name__ == "__main__":
    main()
```
 **Ответ**: flag{elliptic_curves_again}
