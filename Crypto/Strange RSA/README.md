# Strange **RSA**
**Описание**: тут очень странная генерация ключа. Напоминает **RSA**, но что-то не то.
Это действительно странная генерация ключа, более того она бесполезная. Но это не мешает использовать атаку Винера.
Можем заметить, что d крайне мало, всего 400 бит в то время, как n 2048 бит, а значит к можно применить «атаку Винера», и найти **p и q** на которые раскладывается n.
Только у нас не функция Эйлера, а $φ(n)=(p-57)*(q-57)$, но для атаки это не имеет значение.
1. Представляем дробь $\frac{e}{n}=[a_0,a_1,a_2,…,a_l ]=a_0+\frac{1}{a_1+\frac{1}{a_2+⋯}}$ непрерывной дроби
2. Находим подходящие дроби $\frac{P_k}{Q_k}$  по формуле $P_k=a_k*P_{k-1}+P_{k-2}, Q_k=a_k*Q_{k-1}+Q_{k-2}$, где $P_0=a_0,P_{-1}=1,Q_0=1,Q_{-1}=0$
3. Для `k` от `0` до `l`:
3.1. Предполагаем, что  $d=Q_k,j=P_k$, такие что $ed-j*φ(n)=1$
3.2. Находим $φ(n)=\frac{ed-1}{j}$
3.3. Так как $φ(n)=(p-57)*(q-57)=pq-57(p+q)+57^2=n-57(p+q)+57^2⇒g=p+q=\frac{n+57^2-φ(n)}{57}$, находим $g = p+q$ по формуле
3.4. Если $g = p + q$; $n=pq$ то по теореме Виета **p и q** корни уравнения $x^2-gx+n=0$, решая его находим **p и q**
3.5. Если $pq = n$, то заканчиваем алгоритм
Найдя **p и q** находим $d_1:ed_1=1 (\mod (p-1)(q-1))$.
$m=c^{d_1}  (\mod n)$.

Можно реализовать следующий код на языке **Python**:

```python
from Cryptodome.Util.number import long_to_bytes

n = 56752…033
d = 14484…619
c = 34549…995

def Drob(a, b):
    A = []
    while b != 0:
        q, r = a // b, a % b
        A.append(q)
        a, b = b, r
    return A

def P_Q(A):
    P = [A[0], A[1]*A[0] + 1] + [0]*(len(A)-2)
    Q = [1, A[1]] + [0]*(len(A)-2)
    for i in range(2, len(A)):
        P[i] = A[i]*P[i-1] + P[i-2]
        Q[i] = A[i]*Q[i-1] + Q[i-2]
    return P, Q

def sqrt_D(D):
    N, V = 0, D
    a = D
    while a**2 != D:
        a = (N + V) // 2
        if a**2 > D:
            V = a
        else:
            N = a
        if V - N <= 1:
            break
    return a

def decrypt():
    P, Q = P_Q(Drob(d, n))
    for i in range(len(P)):
        k = P[i]
        e = Q[i]
        if k !=0 and (e*d - 1) % k == 0:
            fi = (e*d - 1) // k
            if (fi - n - 57*57) % 57 == 0:
                p_q = -(fi - n - 57*57) // 57
                D = (p_q)**2 - 4*n
                D = sqrt_D(D)
                p = (p_q + D) // 2
                q = (p_q - D) // 2
                if p*q == n:
                    return p, q

def main():
    p, q = decrypt()
    fi = (p - 1)*(q - 1)
    e = pow(d, -1, fi)
    m = pow(c, e, n)
    print(long_to_bytes(m))

if __name__ == "__main__":
    main()

```    
 **Ответ**: flag{th1s_k3y_d03s_n0t_3v3n_w0rk}
