# Writeup 

В описании к задаче дан IP и порт, сканировать тут нечего, поэтому сразу двигаем на веб

![telegram-cloud-photo-size-4-5961914880799913501-w](https://github.com/user-attachments/assets/df8d303b-e8e7-4217-b3e4-255965bf687d)

Написано оно на пайтоне 

![telegram-cloud-photo-size-4-5961682222421489333-w](https://github.com/user-attachments/assets/053c4352-c498-4ac5-b870-6c255b045b99)

Проходим несложную регистрацию и получаем доступ к функционалу приложения – генератор паролей и случайных числ.

![telegram-cloud-photo-size-4-5962064169568155221-w](https://github.com/user-attachments/assets/03795376-9989-4752-a93c-8967de4e219a)

![telegram-cloud-photo-size-4-5961748957623334434-w](https://github.com/user-attachments/assets/784a2db7-bfe7-42c6-922f-e0fbb232c7bd)

![telegram-cloud-photo-size-4-5959581442247866050-w](https://github.com/user-attachments/assets/c4acd1ce-eb90-48f9-9971-87469279b3f3)

Негусто. Однако помимо доступов к приложению нам была присвоена сессионная кука

![telegram-cloud-photo-size-4-5961785731133322915-w](https://github.com/user-attachments/assets/beb45a3d-6e19-4ef5-968a-90e62baa019a)

И кука эта оказалась защищена слабым секретом, который успешно сбрутился при помощи модуля flask_unsign. Секретом оказался manchester.

Кука содержит в себе юзернейм, юзер-айди и булеан параметр id_vip_user, коим мы не являемся

![telegram-cloud-photo-size-4-5962024797602952764-w](https://github.com/user-attachments/assets/160fedb8-f436-4ed9-8937-21a0a34aaa04)

Подписываем, вставляем в браузер и получаем доступ к новому функционалу приложения – to-do листу и Kittys's gallery 

To-do в себе чего-то интересного не содержит 

А Kitty's gallery содержит в себе фото котят. Не соврали в названии, выходит 

![telegram-cloud-photo-size-4-5962007471704880873-w](https://github.com/user-attachments/assets/00c0e5a1-6ac5-4e26-949c-522c4aaf392d)

Но интересны здесь не столько сами котята, сколько обращение к апи при подгрузке станицы:

![telegram-cloud-photo-size-4-5959889412877825740-w](https://github.com/user-attachments/assets/9964368d-7284-4fb1-9828-e6c3da7ea9e2)

Понижаем api до v1, получаем информацию о некоем параметре file, получаем arbitrary file read

![telegram-cloud-photo-size-4-5961893891294738101-w](https://github.com/user-attachments/assets/1dbeee38-cd2d-48ac-854e-f640425c1f3c)

Используя AFR собираем слелущий набор данных: 
- username –> /etc/passwd
- modname –> flask.app by default
- flask path –> можно найти, вызвав ошибку в приложении. Например, попытаться прочитать /etc/shadow
- MAC –> /sys/class/net/eth0/address
- machine id –> /etc/machineid + /proc/self/cgroup

Собрав все необходимые данные, клонируем себе Werkzeuger и запускаем генерацию пина на основе имеющихся данных: 

![telegram-cloud-photo-size-4-5961992267520652940-w](https://github.com/user-attachments/assets/fa7656ea-fdd4-4e8f-bb96-a87eccbeaafd)

В результате работы скрипта получаем несколько пинов:

![telegram-cloud-photo-size-4-5961698096620615201-w](https://github.com/user-attachments/assets/7e8b0395-e900-4a2e-ac9d-3512ca26ce08)

Прежде чем перейти дальше, нужно разобраться с ошибкой:

![telegram-cloud-photo-size-4-5961719661651408446-w](https://github.com/user-attachments/assets/98ea831a-2372-4016-851c-ece1041a2666)

Чтобы победить этот этап просто подменяем заголовок Host с IP на localhost:

![telegram-cloud-photo-size-4-5961802094958720598-w](https://github.com/user-attachments/assets/862ce30a-9aa7-4e57-b5cc-2f778c4e77d8)

И здесь, наконец, получаем то заветное RCE:

![telegram-cloud-photo-size-4-5961796124954179133-w](https://github.com/user-attachments/assets/a01a510a-98c5-45a3-a605-46439c9e6283)


Пробрасываем себе шелл любым удобным способом и оказываемся в системе:

После перечисления ресурсов системы, с поиском вектора повышения могло повезти, а могло не повезти. Гарантированный способ увидеть что-то неладное – мониторинг процессов при помощи pspy:

![telegram-cloud-photo-size-4-5961673280299579049-w](https://github.com/user-attachments/assets/610c43c7-7fe1-4ae2-979b-44c8f26a8bcd)


Раз в три минуты запускается некий скрипт /root/healthcheck.sh, похожую директорию можно было найти в /opt. А подождав еще немного, можно было увидеть, как от имени рута выполняется rm-rf по директории /opt/healthcheck/*, после чего туда записывается и выполняется какой-то скрипт, после чего снова rm -rf /opt/healthcheck/*. 

Поймать тайминг и прочитать скрипт – наша первичная цель:

![telegram-cloud-photo-size-4-5962045658259109416-w](https://github.com/user-attachments/assets/ea9782e4-0947-47b4-b8f6-1b31534ba6ac)


Скрипт безобиден и просто собирает информацию о состоянии системы, однако можно увидеть, что он импортирует 4 сторонних модуля и выполняется от имени рута. А права-то на директорию у нас rwx. 

Дожидаемся очередную итерацию крона и пишем скрипт:

```
echo "import os; os.system('cp /bin/bash /tmp/bash && chmod +s /tmp/bash')" > /opt/healthcheck/psutil.py
```
Скрипт healthcheck.py отработает с ошибкой, но подарит нам бинарник bash, принадлежащий руту и повесит на него SUID.

Дожидаемся, проверяем, запускаем.

![telegram-cloud-photo-size-4-5961703237696468520-y](https://github.com/user-attachments/assets/4facb5de-1173-4d66-85da-294765ebdd1e)



